

#후위 구현,,!
T = int(input())



for tc in range(T):

    infix = input().rstrip()



#핵심은 else의 while부분,,! => 우선순위 규칙을 만들어서 하는 부분엣,,!


'''


백트래킹 : dfs업그레이드 판! 




'''

'''


연습문제! 부분 집합의 합


1 : 포함
0 : 미포함


백트래킹에 적합한 dfs구조를 만들어야 한다! 

s라는 변수,,! (그 전까지의 합) => 판단을 하게 끔! 더할지 말지,,,! 
=> i-1 원소까지 고려한 합

t : 찾으려는 합! 


cf) 양갈래면 재귀,,,? 이진탐색의 경우는 달라! 


더해서 넘기거나, 

그냥 넘거줌,,! 



.. 모르겟다,,, 

어떡하지,, 어우,,
'''


'''
순열


순열, 부분집합, 조합 -> 재귀로 만들줄 알아야함,,! 결국에는! 



i 인덱스가 N크기와 같아지면! 순열완성! 


많이 그려보자,,! 손으로 어떤 식으로 동작하는지! 


순열생성과정 많이 그려보자,,! 





'''



'''


분활정복,,, 반반반반,, => 로그 n시간 걸린다! 


'''


#순열 구하기!

def f(i, n):

    if i == n :
        print(p)
    else:
        for j in range(i, n):
            p[i], p[j] = p[j], p[i]
            p(i+1, n)
            p[i], p[j] = p[j], p[i]



def f2(i, n, r):

    if i == r :
        print(p[0:r])
    else:
        for j in range(i, n):
            p[i], p[j] = p[j], p[i]
            p(i+1, n, r)
            p[i], p[j] = p[j], p[i]
#숫자는 n개주고 r개의 부분집합을 고르게 되는 경우의 수!




p = [1,2,3,4,5]



'''

백트래킹! (기본은 dfs)
다 해보면 시간이 너무 오래걸려,,! 그래서 중간에 안해보는 경우를! 

끝까지 다 만들고 판단 한느 것이 아니라, 중간에 확인을 해본다! 

now와 now +1 의 관계

다음이 여러개면 그에 맞게 또 재귀,,! 





가지치기 : 현재에서 다음으로 가는데 다음으로 가도 되는지 확인하겠다,,!

가도 되는지 확인 하는 조건이 바로 "가지치기"



백트래킹 스킬

"패스" : 내가 어떻게 왓는지 기록! 

-1 : 모름, 0 : 사용안함 , 1 : 사용함

'''


'''

앤 캐슬 힌트!


현재 말이 있는 row에서 다음 row+1로 가는것을 생각! 

col[3]의 값이 1이면 거기에 있구나 판단! 두고 안두고를 알 수 있ㄷ,,! 이거 저번에 알려준거 같은데?!
=> 그 col라인 쭉 쓰면 안되니깐! 한 점이 아니라!! 



보이게 하는 것(프로그램같이 돌리는 것은 ㄴ)은 콘솔로 해라! 


'''


'''

백트래킹 대표 문제


주사위를 n번 던져서 나올 수 있는 눈의 조합

=> 
현재랑 다음을 생각하기 위해서,,! 

now : 내가 몇 번째 주사위를 던질 것인가?




단! 조건이 들어가면 이제 백트래킹! 


내가 만들어가는 과정중에 판단을 하는 것! 그게 바로 백트래킹,,!!! 



'''
