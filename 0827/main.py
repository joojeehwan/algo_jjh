'''

트리

탐색의 시작이 곧 루트는 아님!

탐색은 어디서나 가능! 


이진트리,,


최대 개수,,! 그 다음 최대보다 하나가 작네?

3번째 칸 2제곱번쨰인인데! 2제곱 -1이 그 전까지의 최대 갯수! 


포화이진트리
- 높이에 맞게 항상 최대 트리!
- 루트를 1번! 다른 이진트리와의 차이점,,!(다른 이진트리는 다른 번호가 루트가 될 수 있음 )

완전이진트리
- 왼쪽이 비면 안돼!

편향이진트리
- 높이 h에 대한 최소 개수의 노드를 가지면서,, 한쪽 방향의 자식 노드만을,,
=> 야 이거 ㄴ근데 선형이랑 뭐가 달라?



순회?

나중에는 섞어서 쓴다고 하네,, 핫ㅅ,,,


전위순회,,, 약간 dfs랑 비슷?!

순회는 시작한 노드를 정점으로 하는 서브트리만 순회하고 끝이 난다!

존재하는 정점을 돌려야지,,!
p,15 들어가서 검사하는 구조!


후위순회 특징,, 맨 마지막에 루트가 처리



p.24 포환 / 완전 이진트리의 저장 방법!

마지막 ㄱ밧을 알 수 있어서! 그 마지막 값 보다 작은 것들에 대해서만 탐색 할 수 이써! 


플로우연산? 애 보다 작은 정수중 가장 큰 값 => 소수점 버리면 돼!

포화/ 이진 트리가 아니더라도,, 그 번호 규칙을 따르고 있다면! 여기 페이지의 공식이 적용될것,,!! 그렇다고 포화/이진이 되는 것은 아니다!


노드를 선택하는 숫자규칙이 같으면! 배열로 표현이 가능,,! 그러나 빈공간이 생긱는 단점이 생기긴해,, !(편향)



연결리스트도 공부해라,,!




'''




'''

13
1 2 1 3 2 4 3 5 3 6 


6
1 2 1 3 2 4 3 5 3 6 

'''

def pre_order(n):

    if n: #유효한 정점이면
        print(n)
        pre_order(left[n])  #n의 왼쪽 자식으로 이동
        pre_order(right[n]) #n의 오른쪽 자식으로 이동

def in_order(n):

    if n: #유효한 정점이면

        in_order(left[n])  #n의 왼쪽 자식으로 이동
        print(n)
        in_order(right[n]) #n의 오른쪽 자식으로 이동

def post_order(n):

    if n: #유효한 정점이면

        post_order(left[n])  #n의 왼쪽 자식으로 이동
        post_order(right[n]) #n의 오른쪽 자식으로 이동
        print(n)

V = int(input())

edge = list(map(int, input().split()))

E = V - 1 #V개의 정점이 있는 트리의 간선 수

left = [0] * (V+1) #부모를 인덱스로 자식번호 저장
right = [0] * (V+1)
par = [0] * (V+1)

for i in range(E):

    p,c = edge[i*2], edge[i*2 + 1]

    if left[p] == 0 : #p의 왼쪽 자식이 없으면
        left[p] = c
        
    else:
        right[p] = c # 왼쪽 자식이 있으묜 오른쪽 자식으로 저장

    par[c] = p # (1) 조상을 찾는데 사용!
               # (2) 루트를 찾는데에도,,! 값이 0인 녀석은 루트자나!
               # 자식을 인덱스로 부모 번호 저장하는 경우,,!



#계속 조상 쫒아 가는 것!
c = 6
while par[c]:
    print(par[c])
    c = par[c]


#부모가 없으면 root
root = 1
while par[root]: #root로 추정한 정점이 부모가 있으면
    root += 1
print(root) #만약에 1이 출력이 되면 root로 추정한 곳이 루트 인것! 그게 아니라면 par[root]가 값이 있어서 0이외의 값이 들어가서 root값이 1 증가 했을 것!

print("안녕")

'''
왼쪽 자식이 작아야 한다는 규칙이 있다면,,! 만약에 작은게 더 나중에 ㄷㄹ어오면
이전의 큰값이 레프트에 있다가 오른족으로 옮겨가야 한다
        
'''

pre_order(1)
# in_order(1)
# post_order(1)


#내용을 새로운 인덱스로 하여서 다음 자리를 찾아가는 작업은 와일문으로!




#################################



'''

이진탐색 트리,,! 

이지선다,, 왼쪽 오른족 스멜,,
=> 꼭 재귀일 필요는 없다,,! 

p. 39 
평균의 경우 로그는 밑이 2! 

최악의 경우,, 편향! 




힙

최대힙 : 1) 부모 > 자식 2) 완전 이진 트리

최소힙 : 1) 부모 < 자식 2) 완전 이진트리


부모 노드 인덱스 구하기?? => x인덱스  // 2 = x의 부모 노드 인덱스





부모가 항상 1도 아니다!! 주어진 조건대로만,,! 

그 서브트리에서만 순회한다! 

그 서브트리의 개수는 루트 포함! 


'''


'''

정리 전반기

1. 1,2차 배열 인덱스 연산,,! 

2. str 도 1,2차 인덱스 연산,, ! 

3. 스택(dfs)과 큐(bfs)

4. 재귀,,! 중요! 백트래킹 같은거! 


월요일 오후에 최고의 컨디션이 나오도록! 

처음 만든 코드에 너무 집중 x...!

문제를 잘 읽어봐라,,! 

제출횟수 확인하자!! 서버시간 기준이라서,,! 남은 제출시간을 잘 알자! 

여유있게 제출하자,,! 

최악의 경우 떨어지더라도,,! 다음에 붙으면된다! 공부 다시 시작! 

im범위는 인덱스 연산,,! 정도! 1,2차 배열! 

내장함수 사용 가능! 

일단 입력이라도,, 입력부터,,!! 이틀이라도 열심히 하면 가능한 시험이다!! 

리스트 1, 2 복습해라,,!! 컨디션만 좋으면 붙을 수 있는 시험! 


'''


'''

다익스트라,,,! : bfs응용!  heap으로 만듬!  bfs에서 큐 안쓰고 힙 쓰면 그게 바로 다익스트라! 



<heap...!>


삽입

1. 완전 이진 트리에 맞게 노드 위치 잡기! (1번만!)
2. 해당 위치에 data 추가 (1번만!)
3. 해당 data가 알맞는 위치가 될 때가지 부모랑 비교해가면 swap ( 트리의 depth만큼 비교,,! )

log N

삭제

1. 맨 위에 있는 data를 마지막에 추가된 data와 swap(완전이진탐색트리 유지) (1번만)
2. 맨 마지막에 있는 data를 꺼냄 (1번만)
3. 맨 위에 있는 data를 알맞는 위치까지 swap에 나감 (트리의 depth만큼,,!)
(왼쪽 자식과 오른쪽 자식 중 더 알맞는 자식과 swap)

삽입과똑같은 시간,,!

log N

구현까지는 하면 좋지만,, 지금의 나에겐 HEAVY!


구래소 HEAP을 언제 써먹는데?! 

힙과 비슷하게 쓰이는 것? 정렬이 있음,,! 
가장 큰거 쓸려면 굳이 맥스 힙 안쓰고 내림차순 정렬하는게 맞지 않나?!


1. 정렬

삽일 할때마다 전체를 다시 정렬해야해,,, 시간이 너무,, 


2. heap 

힙은 삽입시에 시간이 아주 적다아! 



정렬보다 힙이 좋을 때? 
=> 데이터를 사용하는 도중에 값이 변경되거나 추가되는 경우

힙보다 정렬이 좋을 때?
1) => 데이터를 사용하는 도중에 값이 변경되거나 추가되면 비효울적임!
따라서 딱 1번 정렬해두고 변경사항없이 계속 쓰는 경우 유리! 

2) => ex) "5번째 큰수를 찾아라! "  정렬의 경우 바로 값 ㅃ보으면 되지만, 힙의 경우 5번 뽑아 봐야한다! 
즉, 중간에 있는 수를 가져와햐 할때 정렬이 더 유리! 


heap은 1차원 배열로 "도" 구현한다! 


'''