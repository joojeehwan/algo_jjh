''''

아이디어
1. 중복되는 가로줄은 삭제한다. (set으로 바꾸면 자동으로 같은 원소는 제외됨)

2. 가로줄 하나에는 암호 코드가 한 세트 이상이 들어있다.

3. 암호 코드 한 세트 (10진수 기준 길이 : 8 / 16진수 기준 길이 : 14의 배수 / 2진수 기준 길이 : 56의 배수)

4. 16진 암호 코드로 된 가로줄 하나를 2진 암호 코드로 변환한다.
   변환 후 오른쪽에 있는 0은 다 지워도 된다. (어떤 암호던 마지막은 1로 끝나기 때문)

5.2진 암호 코드를 오른쪽에서 부터 읽어가면서 10진수로 변환한다.
  10진수 암호 숫자 하나가 차지하는 2진수 암호의 길이는 7의 배수가 된다.
  예) (10진수) 9 = 0001011 = 00000011001111 = 000000000111000111111 ...
  그렇기 때문에 2진수 암호의 전체 길이와 상관없이 0과 1의 비율을 통해 암호의 10진수를 알아낼 수 있다.
  -> 3:1:1:2

6.2진 코드를 뒤에서부터 읽어나가면서, 1의 개수를 세고(n4), 0의 개수를 세고(n3), 1의 개수를 세면(n2), n1도 알 수 있다.
  n1 = 7*배수 - (n2 + n3 + n4)
  예) n1:1:1:2 이면 배수는 1이고, n1은 3
  n1:2:2:4 이면 배수는 2이고, n1은 6
  n1:3:3:6 이면 배수는 3이고, n1은 9
  배수는 n2, n3, n4의 최소값임을 알 수 있다.

7. n1, n2, n3, n4를 배수로 나누어 준다. (비율을 알기 위함)

8. 비율을 통해 10진수를 얻을 수 있다.
 0 : (3:2:1:1)
 1 : (2:2:2:1)
 2 : (2:1:2:2)
 ...
 9 : (3:1:1:2)

9. 10진수 8개를 얻으면 암호 코드 한 세트를 얻은 것이다. 암호 코드 한 세트를 얻으면 유효한 암호 코드인지 검사한다. (문제에 유효한 코드의 속성이 주어짐)




'''



import sys

sys.stdin = open("swea_1242.txt")


hex_to_bin = {"0":"0000",
             "1":"0001",
             "2":"0010",
             "3": "0010",
             "4": "0010",
             "5": "0010",
             "6": "0010",
             "7": "0010",
             "8": "0010",
             "9": "0010",
             "A": "0010",
             "B": "0010",
             "C": "0010",
             "D": "0010",
             "E": "0010",
             "F": "0010",
             }


code = {

    (3,2,1,1), (2,2,2,1), (2,1,2,2), (1,4,1,1), (1,1,3,2),
    (1,2,3,1), (1,1,1,4), (1,3,1,2), (1,2,1,3), (3,1,1,2)

}
#
# T = int(input())
#
# for tc in range(1, T+1):
#     N, M = map(int, input().split())
#     lst = list(set([input() for _ in range(N)]))
#
#     dec = []
#
#     for i in range(len(lst)):
#         temp = lst[i]
#         for j in range(M):
#             if temp[j]







